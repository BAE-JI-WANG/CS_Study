> 본 글은 이화여대 반효경 교수님의 [운영체제 강의(2014)](http://www.kocw.net/home/search/kemView.do?kemId=1046323) 내용에 대해 학습하고 정리한 내용입니다.


# 14. Process Synchronization 3

## 0. Bounded-Buffer Problem (= 생산자-소비자 문제)

버퍼의 크기가 `유한한` 환경에서 발생한다. 생산자 소비자는 모두 N개가 위치할 수 있다.

![](https://i.imgur.com/FSQt64r.png)

위 그림에서 주환색 동그라미가 데이터로 채워진 버퍼를 의미하며, 색이 없는 동그라미는 비어있는 버퍼이다. 

이 때, 생산자가 비어있는 버퍼에 데이터를 만들어 집어넣게되는데 별다른 조치가 없다면 다른 생산자도 동일한 빈 버퍼에 데이터를 할당하게 된다. 즉 thread-safe하지않게 되는 것이다. 

이 때문에 생산자는 다음의 순서를 거쳐서 버퍼에 데이터를 넣어준다. 

1. 비어있는 버퍼가 있는지 확인한다 (없으면 대기 -> 소비자가 꺼내가서 빈 버퍼가 생길 때 까지)
2. 공유 데이터에 lock을 건다 
3. 비어있는 버퍼에 데이터를 입력하고, 버퍼를 조작한다. (다음 생산 위치로 이동시킨다)
4. 공유 데이터의 lock을 푼다
5. 채워진 버퍼의 수를 하나 증가시킨다

이 처럼 공유 데이터에 lock을 걸게 되면 A 생산자가 비어있는 버퍼에 데이터를 할당할 때, B/C/D등의 다른 생산자들은 공유 버퍼에 접근하지 못하게 된다. 

소비자도 마찬가지이다!

소비자는 채워져있는 버퍼를 가져오고 싶어하는데, 마찬가지로 2명 이상으 소비자가 같은 버퍼를 가져오면 안된다. 이에 생산자와 비슷한 과정을 거쳐서 버퍼를 얻게된다. 

1. 채워져있는 버퍼를 찾는다. (없으면 대기 -> 생산자가 버퍼에 데이터를 채울 때 까지)
2. 공유 데이터에 lock을 건다
3. 채워진 버퍼에서 데이터를 꺼내고, 버퍼를 조작한다 (다음 소비 위치로 이동시킨다)
4. 공유 데이터의 lock을 푼다
5. 빈 버퍼의 수를 하나 증가시킨다. 

버퍼에 데이터가 꽉 차게되는 경우 다음에 들어오는 생산자들은 더 이상 생산을 하지 못하게 된다. 이 때 소비자가 데이터를 가져가줘야 생산자가 다시 데이터를 넣어줄 수 있다.

위 상황에서는 두 개의 세마포어가 사용된다. 

- Binary Semaphore
    - 공유 데이터의 mutual exclusion을 위해 사용된다. 
- Counting Semaphore
    - 남아있는 full/empty 버퍼의 수를 표시해준다. 

위 생산자-소비자 문제를 의사(pseudo) 코드로 봐보자. 

```c
// semaphore
full = 0;
empty = n;
mutex = 1
```

처음 상태에서 비어있는 버퍼로만 구성되어 있는 것이다. 그리고 mutex는 생산자 간, 소비자 간 상호 배제를 위해 사용된다.

생산자의 생산 과정을 먼저 살펴보자. 
```c 
// 생산자(Producer)
do {
    x에 아이템 "생산"
    ...
    P(empty);
    P(mutex);
    ...
    버퍼에 x "추가"
    ...
    V(mutex);
    V(full);
} while(1)
```

아이템을 먼저 생산해준다. 그 이후 `P(empty)` 연산을 통해 비어있는 버퍼가 있는지 확인한 후, 있다면 empty의 값을 1만큼 내려준다. 

그 이후 상호 배제를 위해 mutex를 1만큼 내려 0으로 만들어서 다른 생산자나 소비자가 들어오지 못하게 만들어준다. 

그 다음 생산한 아이템을 버퍼에 추가하고, V연산을 통해 mutex를 돌려 놓고, 버퍼를 만들었기에 `V(full)`을 통해 full을 1만큼 올려준다!

소비자의 경우도 비슷하다. 

```c 
// 소비자(Comsumer)
do {
    P(full);
    P(mutex);
    ...
    버퍼에서 y로 아이템을 추출
    ...
    V(mutex);
    V(empty);
    ...
    y에서 아이템 소비
    ...
} while(1)
```

소비자의 경우는 버퍼가 채워져있는지를 먼저 확인해주기 위해 `P(full)` 연산을 수행한다. 그리고 마찬가지로 mutex의 값을 내려 lock해주고 소비 공간인 y로 아이템을 가져온다. 

그리고 다시 unlock해주기 위해 mutex의 값을 1만큼 올려주고, 이제 빈 버퍼가 하나 더 생기는 것이기 때문에 `V(empty)` 연산을 수행해준다. 

보면 생산자는 `P(empty) ~ V(full)`의 과정이고 소비자는 `P(full) ~ V(empty)`의 과정인 것을 볼 수 있다. 말 그대로 자원을 생산/할당하는 생산자의 생산 과정, 획득/소비하는 소비자의 소비 과정을 나타낸 것이다. 

## 1. Readers and Writers Problem

쓰는 역할을 하는 프로세스, 읽는 역할을 하는 프로세스 총 두 종류가 있는 상황이다. 

하나의 프로세스가 DB에 무언가를 작성하고 있을 때, 다른 프로세스가 접근하면 안되는데 접근할 때 발생하는 문제를 의미한다. (대신 읽는 것은 여러 프로세스가 와서 읽어도 된다. 쓰는 작업만 여럿이 동시에 하면 안되는 것이다)

쓰는 동안에는 lock을 걸어 쓰기/읽기 프로세스가 들어오지 못하도록 하고, 읽는 동안에는 lock을 걸지 않고 다른 reader가 들어오고자 하면 허용해줘야 한다. 다만 읽고 있는 도중에 writer가 오면 막아줘야 한다. 이러한 방식을 어떻게 구현해야하는지에 대해서 하나씩 알아보자. 

```c
// shared data
int readcount = 0; // 현재 읽고 있는 프로세스 수
DB; // DB 자체

// semaphore
mutex = 1;
db = 1;
```
 
- readcount
    -  말 그대로 현재 읽고 있는 프로세스의 수를 나타낸다. 

- mutex
    - 추후에 읽기 시작하는 프로세스가 생기면 readcount를 증가시켜주고, 읽기를 끝내면 readcount를 감소시켜줘야한다. readcount 또한 공유 자원이기 때문에 thread-safe에 유의해야 한다. 
    - 이를를 사용하여 readcount를 lock/unlock 해줘야 한다. 
- db
    - DB를 lock/unlock해주는 역할을 한다 

```c
// Writer

P(db); // db에 Lock
...
DB에 작성
...
V(db); // db를 unlock
```

작성자는 간단하다. DB에 작성하기 전에 lock을 걸어서 다른 프로세스가 들어오지 못하도록 하고, 작성을 마치면 다시 unlock해주는 과정이다. 

```c
// Reader
P(mutex)
readcount++;
if (readcount == 1) P(db); // writer를 막고, reader는 허용해준다.
V(mutex);
...
DB에서 읽기
...
P(mutex);
readcount--;
if (readcount == 0) V(db) // writer가 작성이 가능하도록 허용
V(mutex);
```
처음에는 `P(mutex)`를 통해 readcount에 대한 접근을 막고 시작해준다.

처음으로 읽는 프로세스는 readcount를 증가시키고 `P(db)`를 통해 DB에 Lock을 걸어준다. 이후 최초가 아닌 reader라면 lock은 하지 않고 읽기만 하는 것이다. 

그리고 `V(mutex)`로 readcount를 unlock 해준다. 

데이터를 읽고 나올 때도 마찬가지로 `P(mutex)`로 readcount를 lock하고 readcount를 줄여준다. 마지막으로 읽기를 종료하는 reader가 `V(db)` 수행을 통해 DB를 unlock해준다. 즉 복수의 reader가 읽기 연산을 하다가 마지막에 남은 reader가 나올 때 DB를 unlock하여 writer가 들어올 수 있도록 처리해주는 것이다. 이후 `V(mutex)` 연산을 통해 readcount를 unlock 해준다. 

다만 마지막 reader가 빠져나갈 때 까지 writer는 기다려야하는 것이다. reader가 계속 들어오게 되면 writer는 계속 기다리게 되는 상황이 발생하게 되는 starvation 문제가 발생하게 된다. 

## 2. Dining Philosophers Problem

원탁에서 철학자들이 식사할 때 발생하는 문제이다. 철학자들은 생각을 할 수 있고, 식사를 할 수 있다. 

![](https://upload.wikimedia.org/wikipedia/commons/7/7b/An_illustration_of_the_dining_philosophers_problem.png)


다만 철학자가 5명인데 젓가락도 5개여서 식사하는데 문제가 발생하는 것이다. 사진에서는 포크이니까... 식사하는데 2개의 포크가 필요하다고 가정해보자. 

![](https://i.imgur.com/MnGk9lD.png)

위 처럼 가운데 낀 사람은 식사를 할 수가 없게 되는 문제인 것이다. 포크를 공유 자원으로 보는 것이다.

여기서 세마포어 역할을 하는 포크는 총 5개이고, 각각 1의 값을 초기에 갖는다. 

```c
// n번째 철학자의 루틴
do {
    P(chopstick[i]); // 왼쪽 젓가락 잡기
    P(chopstick[(i+1) % 5]); // 오른쪽 젓가락 잡기
    ...
    eat();
    ...
    V(chopstick[i]); // 왼쪽 젓가락 놓기
    V(chopstick[(i+1) % 5]); // 오른쪽 젓가락 놓기
    ...
    think();
    ...        
}
```

이렇게 간단하게 젓가락을 들고 식사를 하고, 젓가락을 다시 놓고 생각을 하는 과정을 나타내봤다. 

위 코드는 deadlock의 가능성이 있다. 
바로 모든 철학자가 왼쪽 젓가락을 동시에 집어버리면 오른쪽 젓가락은 영원히 잡을 수 없는 상황에서 발생한다. 

해결 방안은 여러가지가 있을 수 있다.

- 4명의 철학자만이 테이블에 동시에 앉을 수 있도록 한다. 
- 젓가락을 두 개 모두 집을 수 있을 때만 젓가락을 집게 해준다. 
- 짝수 철학자는 왼쪽 젓가락, 홀수 첧학자는 오른쪽 젓가락을 집도록 해준다.
    
    
"젓가락을 두 개 모두 집을 수 있을 때만 젓가락을 집게 해준다." 의 방법을 코드로 살펴보자!

![](https://i.imgur.com/ropgV7n.png)

우선 `self[n] = 0`은 n번째 철학자는 젓가락을 들 자격이 없다는 것이고 `self[n] = 1`인 경우 n번째 철학자가 젓가락을 들 자격이 있다는 것이다. 

그리고 state는 생각하는, 배고픈, 식사하는 상태를 나타내준다. state의 경우 본인 말고도 타인이 상태값을 바꿀 수 있기 때문에 mutex를 두어 lock/unlock해준다.

코드를 살펴보자
(다만 세마포어 철학에 잘 맞지 않는 부분이 있다고 한다. 초기값에 따라 자원을 사용 유무가 결정되는데 초기값이 0이고 어떠한 조건에 따라 값이 1이 되어 수행 가능한 상태가 된다는 것이 모순된다는 것 같다.)
```c
// 젓가락을 드는 메서드
void pickup(int i) {
    P(mutex);
    state[i] = hungry;
    test(i);
    V(mutex);
    P(self[i]);
}
```

젓가락을 들고자 할 때 state를 바꿔줘야 하기 때문에 먼저 mutex값을 확인하고 내려준다. 그리고 본인의 상태를 바꿔주고 test메서드를 타게 된다. 

```c
void test(int i) {
    if (state[(i+4) % 5] != eating && state[i] == hungry && state[(i+1) % 5] != eating) {
        state[i] = eating;
        V(self[i]);
    }
}
```

test 메서드의 경우 본인을 기준으로 왼쪽 철학자, 오른쪽 철학자가 밥을 먹고 있는 상황인지 체크한다. 둘 다 식사중이 아니고 본인이 배고픈 상태라면 본인의 상태를 식사중으로 만들어 주고 `self[i]`를 1만큼 증가시켜 "젓가락을 들 수 있게" 만들어준다. 

그러면 다시 pickup 메서드로 와서 mutex를 unlock해주고 `P(self[i])`를 해줘서 젓가락을 들게 해준다! 

```c
void putdown(int i) {
    P(mutex);
    state[i] = thinking;
    test((i+4) % 5);
    test((i+1) % 5);
    V(mutex);
}
```

이제 젓가락을 내려놓는 과정을 보자. state를 변경해줘야 하기 때문에 mutex를 다시 lock해주고, 생각하는 상태로 바꿔준다. 

그리고 test 메서드를 통해 왼쪽, 오른쪽 철학자를 챙겨준다. 즉 왼쪽, 오른쪽 철학자가 배고픈 상태인데 식사를 못하고 대기하고 있는 상태인지 확인해주고, 식사가 가능한 상황이라면 젓가락을 들 수 있게 만들어주는 것이다 

이 과정이 끝나면 다시 mutex를 unlock해주게 된다. 

## 3. Monitor

기존 세마포어에는 다음과 같은 문제점이 있었다. 

- 코딩하기 힘들다...
- 정확성의 입증이 어렵다
- 자발적 협력이 필요하다
- 한 번의 실수가 모든 시스템에 치명적인 영향을 미친다. 

![](https://i.imgur.com/hHm6SQB.png)

- 휴먼 에러가 발생가능하다는 것...!
    - V와 P연산을 반대로 적어버리면 Mutual Exclusion이 깨져버린다    
    - P를 두 번 사용하게 되면 deadlock이 발생하게 된다. 

Monitor의 경우도 마찬가지로 공유 자원에 접근할 때 발생하는 문제를 해결하기 위한 방법 중 하나이다. 

Monitor란 동시 수행중인 프로세스 사이에서 추상 데이터 타입의 안전한 공유를 보장하기 위한 고수준의 synchronization 구조이다.

Monitor라는 개념 내에 공유 자원을 넣어두고, 공유 자원을 처리하는 operation 연산 또한 넣어두게 된다. 그래서 이제 공유 자원에 접근하려면 무조건 monotor를 거쳐야하는 것이다. 

monitor는 원천적으로 operation 연산이 동시에 실행되지 않도록 되어있다! 그러면 어떠한 장점이 있느냐! 프로그래머는 lock을 걸지 않아도 된다. 

왜냐하면 operation 연산 자체가 동시에 수행되지 않도록 되어있기 때문에 프로그래머는 이 부분을 고려하지 않아도 되는 것이다. 

정리해보면 다음과 같다. 

- Monitor 내에서는 한 번에 하나의 프로세스만이 실행 가능하다.
    - 나머지 프로세스들은 entry queue에서 줄을 서서 기다린다
- 프로그래머가 동기화를 위한 제약 조건을 명시적으로 작성하지 않아도 된다. 
- 프로세스가 monitor 내에서 기다릴 수 있도록 하기 위해 condition variable을 사용한다. 
- condition variable은 `wait`와 `signal` 연산에 의해서만 접근 가능하다.
    - `x.wait()`을 호출한 프로세스는 다른 프로세스가 `x.signal()`을 호출하기 전까지는 suspend 된다. 
    - `x.signal()`은 정확하게 하나의 suspend된 프로세스를 resume한다. suspend된 프로세스가 없다면 아무 일도 일어나지 않는다. 

처음에 봤던 생산자-소비자 문제를 세마포어가 아닌 monitor를 사용해서 해결하는 코드를 봐보자.

```c
monitor bounded_buffer {
    int buffer[N];
    condition fill, empty;
    
    void produce(int x) {
        만약 empty buffer가 없다면
            empty.wait(); // 대기!
        x를 empty buffer에 추가
        full.signal();
    }
    
    void consume(int y) {
        만약 full buffer가 없다면
            full.wait(); // 대기!
        buffer에서 아이템을 빼고 y를 저장
        empty.signal();
    }
}
```

condition var는 세마포어처럼 값을 가지는 것이 아니라 자신의 큐에 프로세스를 달아두면서 sleep 시키거나, 큐에서 프로세스를 깨우는 역할만 해주면 된다. 

즉 줄 세우거나, 줄에서 빼주거나 그 역할만 해주는 것이다. 

앞서 말한 것 처럼 세마포어와 달리 값을 갖고 변화시키는 것이 아니라, 생산자 입장에서 비어있는 버퍼가 없다면 empty를 suspend 상태로 만들어서 기다리게 되는 것이다. 소비자 또한 마찬가지로 채워진 버퍼가 없다면 full을 suspend 시키는 것이다. 

만약 생산이 되었다면 full을 signal하여 깨우는 것이고, 소비되어 버퍼에서 데이터가 빠졌다면 empty를 깨우게 되는 것이다. 

이처럼 프로그래머가 별도로 상호 배제를 고려하지 않아도 monitor의 내부 동작으로 가능해지게 되는 것이다!
