> 본 글은 이화여대 반효경 교수님의 [운영체제 강의(2014)](http://www.kocw.net/home/search/kemView.do?kemId=1046323) 내용에 대해 학습하고 정리한 내용입니다.


# 16. Deadlocks 1

## 0. Deadlock이란?

교착 상태라고 불리는 개념이다. 서로가 서로가 끝나기를 기다리는 상황이기도 하다. 

![](https://media.vlpt.us/images/agpine12/post/b997f070-229d-4086-9623-18a28b88b7ce/99471C465A31252E1D.jpeg)

누군가가 비켜줘야 하는데, 누구도 비키지 못하는 상황임을 알 수 있다. 컴퓨터 세계에서도 마찬가지이다. 

A프로세스는 실행하기 위해 B프로세스가 끝나기를 기다리고, B는 C프로세스가 끝나기를, C는 A프로세스가 끝나기를 기다리면 영원히 실행되지 못하게 되는 것이다. 

한 마디로, 일련의 프로세스들이 서로가 가진 자원을 기다리며 block된 상태인 것이다. 

자원에는 하드웨어, 소프트웨어 등을 포함하는 개념이다. 

Deadlock이 발생하는 조건은 네 가지로 아래와 같다. (Deadlock 필요 조건)

- Mutual exclusion (상호 배제)
    - 매 순간 하나의 프로세스만이 자원을 사용할 수 있어야 한다. 
    - 하나의 프로세스만이 자원을 사용할 수 있어야 동시에 다른 자원이 작업을 못하기에 deadlock을 유발할 수 있다.
- No preemption (비선점)
    - 프로세스는 자원을 스스로 내어놓을 뿐 강제로 뺏기지 않는다. 
    - 즉, 한 번 점유하고 실행 중에는 뺏기지 않기 때문에 deadlock을 유발하는 상황 중 하나라고 볼 수 있다. 
- Hold and wait (보유대기)
    - 자원을 가진 프로세스가 다른 자원을 기다릴 때, 보유 자원을 놓지 않고 계속 가지고 있게 되면 deadlock을 유발할 수 있다.
- Circular wait (순환대기)
    - 자원을 기다리는 프로세스 간에 사이클이 형성되어야 한다. 즉 꼬리에 꼬리를 무는 순환의 상황이 되어야 한다는 것이다. 

## 1. Resource-Allocation Graph

![](https://i.imgur.com/BlrZGZP.png)

동그라미가 프로세스이고, 네모들은 자원이다. 

P1은 R2의 자원을 하나 사용하고 있고, R1 자원에 요청하여 기다리고 있다고 볼 수 있다. 이러한 자원 할당 그래프를 통해 deadlock이 발생하는지 유무를 판단할 수 있다. 

우선 그래프에 사이클이 존재하는지 살펴보면 된다.

위 경우, 화살표를 따라가다보면 사이클이 존재함을 알 수 있다. 즉 deadlock이 발생한다고 볼 수 있다. 

무조건 사이클이 존재한다고 해서 deadlock인 것은 아니며 R1,R2같은 자원의 인스턴스가 1개인 경우 deadlock이 발생한다고 볼 수 있다. 즉 하나의 자원만을 가지는데, 사이클까지 생겼다면 맨 앞에서 본 사거리의 차량들의 모습과 유사해지게 된다. 

만약 자원의 인스턴스가 여러 개인 경우는 무조건 적으로 deadlock이 발생하는 것이 아니라, `deadlock이 발생 가능하다`고 볼 수 있다. 

![](https://i.imgur.com/H1J0hdp.png)

위 경우처럼 P1 -> R1 -> P2 순서대로 가면 사이클이 발생하지 않기 때문에 deadlock이 발생되지 않는다고 볼 수 있다. 

## 2. Deadlock의 처리 방법

아래에서 볼 1,2번의 방법은 deadlock을 방지하는 것이고, 3번의 경우는 deadlock을 허용하되 이를 탐지하는 루틴을 두어 발견하게 한다. 4번의 경우는 시스템이 deadlock에 대해 책임지지 않는 경우이다. 

1. Deadlock Prevention
    - 자원 할당 시 deadlock의 4가지 필요 조건 중 어느 하나가 만족되지 않도록 한다. 
2. Deadlock Avoidance
    - 자원 요청에 대한 부가적인 정보를 이용해서 deadlock의 가능성이 없는 경우에만 자원을 할당한다.
    - 시스템 state가 원래 state로 돌아올 수 있는 경우에만 자원을 할당한다. 
3. Deadlock Detection and recovery
    - Deadlock 발생은 허용하되 그에 대한 detection 루틴을 두어 deadlock 발견시 처리(recover)한다.
4. Deadlock Ignorance
    - Deadlock을 시스템이 책임지지 않는다. 
    - 대부분의 OS가 이 방법을 사용한다. 


현대에는 4번처럼 deadlock이 발생할 수 있게 놔두는 편이라고 한다. 왜냐하면 deadlock을 방지하는 오버헤드가 크기 때문에 비효율적이며, 혹여나 deadlock 발생시 프로그래머가 자체적으로 해결하도록 한다.

이제 하나씩 살펴보자.

## 3. Deadlock Prevention

Deadlock을 방지하는 가장 강력한 방법이다. 

앞서 말한 deadlock의 필요조건에 대해 각각 해결책을 살펴보자.

- Mutual Exclusion
    - ME 자체를 막을 수는 없기 때문에, 공유해서는 안되는 자원의 경우는 반드시 성립하도록 한다. 
- Hold and Wait
    - 프로세스가 자원을 요청할 때 다른 어떠한 자원도 가지고 있지 않도록 해준다. 
    - 자원을 가진 상태로 요청을 하다보니 사이클이 발생했기에 이를 방지해주는 것이다. 
    - 프로세스를 시작할 때 처음부터 필요한 모든 자원을 할당해주어 hold and wait를 방지할 수 있다.
        - 하지만 처음 시점이 아니라, 매 시점마다 필요한 자원이 다를 수 있기 때문에 이는 비효율적인 방법이다.
    - 또 다른 방법으로는 자원이 필요한 경우 보유 자원을 모두 놓고 다시 요청하는 것이 있다. 
- No Preemption
    - 프로세스가 어떤 자원을 기다려야 하는 경우 이미 보유한 자원이 선점된다. 
    - 즉 강제로 빼앗기도록 해준 것이다.
    - 이에 모든 필요한 자원을 얻고 나서야 선점 당한 프로세스는 다시 시작된다. 
    - state를 쉽게 저장하고 복원할 수 있는 자원에서 주로 사용된다(CPU, memory)
- Circular Wait
    - 모든 자원 유형에 할당 순서를 정하여 정해진 순서대로만 자원을 할당하도록 해준다. 
    - 예를 들어 순서가 3인 자원 A를 보유 중인 프로세스가 순서가 1인 자원 B를 할당받기 위해서는 우선 A를 놓아야 한다.

이렇게 deadlock을 막을 순 있지만 단점이 있다. 

- 자원의 이용률(utilization) 저하
- 시스템의 성능(throughput) 저하 
- Starvation 문제

## 4. Deadlock Avoidance

자원 요청에 대해 부가적인 정보를 이용해서 자원 할당이 deadlock으로 부터 안전한지 동적으로 확인해서 안전한 경우에만 할당한다고 했었다. 

이를 구현하는 가장 단순한 방법은 프로세스가 시작될 때, 프로세스들이 필요로 하는 각 자원별 최대 사용량을 미리 선언하도록 하는 방법이다. 

대표적인 두 가지의 avoidance 알고리즘이 있다.

- 자원의 인스턴스가 하나 뿐인 경우
    - Resource Allocation Graph algorithm
- 자원의 인스턴스가 여러 개인 경우
    - Banker's Algorithm

### 4-1. Resource Allocation Graph algorithm

![](https://i.imgur.com/bPYmysS.png)

앞서 잠깐 봤던 자원 할당 그래프이다. 

이전과 달리 점선이 추가되었는데 점선의 경우, 항상 프로세스로부터 자원의 방향을 가리키며 프로세스가 해당 자원을 평생 중에 한 번은 요청(사용)할 수 있다라는 의미를 가진다. 

프로세스가 자원을 요청하는 경우 점선은 실선으로 변경된다. 가장 왼쪽 그림부터 보면 P2는 R2에 자원을 요청할 수 있는 상황이다. P2가 자원을 요청한 경우 화살표는 바뀌게 된다. 

이제 P2 -> R2로 향하는 화살표가 실선이 되었다. 즉 요청했다는 의미이다. 이에 가장 오른쪽의 그림을 보면 R2가 P2에 할당됨을 나타내기 위해 화살표에 방향이 바뀌게 되는 것이다. 

이 경우는 deadlock이 아니다. 왜냐하면 P1 -> R2의 요청은 지금 일어난 것이 아니고, 미래에 한 번 요청할 수 있다는 의미이기 때문에 현재에는 요청이 되지 않았다고 볼 수 있다. 그렇기에 deadlock이 아니라고 말할 수 있는 것이다.(운이 나빠서 P1이 R2를 요청했다면 deadlock은 발생 가능하다...)

avoidance 방법의 경우 P1에 R2가 할당되면 deadlock이 발생하기 때문에, 이 때는 자원을 주지 않는다. 왜냐하면 처음 이야기했던 것 처럼 deadlock이 발생 가능한 환경인지 탐색하고 자원을 할당을 한다고 했었기 때문이다. 

추후에 P1이 R1을 반납하고 P2가 R1을 획득함에 따라 화살표가 바뀌게 되면, 그제서야 판단해서 R2를 P1에 줄 수 있을 것이다. 

### 4-2. Banker's Algorithm

![](https://i.imgur.com/8kUn2bW.png)

프로세스가 P1~5로 5개, 자원은 A(10개),B(5개),C(7개) 사용 가능하다고 해보자. 

그러면 특정 시점 T0에 대해서 위의 테이블을 구성할 수 있는 것이다. 

- Allocation
    - 현재 할당된 각 자원의 개수
- Max
    - 평생동안 프로세스가 사용할 각 자원의 수
- Availiable
    - 현재 가용가능한 잔여 자원의 수
- Need(Max-Allocaiton)
    - Max에서 Allocation을 뺀 값으로, 추가 요청할 수 있는 양을 의미한다. 

만약 P1이 A를 1개, C를 2개 요청했다고 해보자. 

그러면 우선 Need에서 A,C의 수를 보고 요청 가능한지 본다. 현재 A:1, C:2로 충분히 요청 가능한 상황이다. (딱 맞게 떨어진다)

하지만 Need의 경우는 앞서 말한 것 처럼, 추가 요청 가능량이기 때문에, 실제 가용(할당) 가능한 수인 Availiable을 봐야한다. 현재 A:3, C:2로 A,C 자원을 줄 수 있는 상황이기에 이 때 자원을 할당해주게 된다. 

만약 P0이 B를 2개 요청했다고 해보자. 이 때도 마찬가지로 우선 Need를 확인하는데 B:4로 요청이 가능한 상황이다. 하지만 현재 Availiable에서 B는 3으로 최대 요청 가능량(Need)인 4보다 작기 때문에 자원을 할당해주지 않게 된다. 

왜냐하면 지금은 2개만 요청해서 가능하긴 하지만, 최대 요청량으로 요청할 수 있기 때문에 이로 인한 deadlock을 미연에 방지하고자 아예 자원을 할당해주지 않게 되는 것이다. 

안전하게 할당해주는 과정을 가지고 있다고 볼 수 있다! 혹시나 최대 요청량으로 요청하면 어쩌지...?를 생각하고 현재 가지고 있는 자원의 수로도 할당이 가능하더라도 미리 방지하고자 아예 할당하지 않는 것이다!
