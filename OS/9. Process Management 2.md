> 본 글은 이화여대 반효경 교수님의 [운영체제 강의(2014)](http://www.kocw.net/home/search/kemView.do?kemId=1046323) 내용에 대해 학습하고 정리한 내용입니다.


# 9. Process Management 2

## 0. 프로세스 생성

앞선 강의에서 자식의 프로세스가 생성될 때, 부모의 프로세스를 복제하여 생성한다고 했었다.

이 때, 부모와 자식의 프로세스가 같다면 메모리 상에 똑같은 것이 두 개 있는 것과 같다. 이에 중복의 이슈 때문에 복제(copy)하지 않고 주소 공간을 공유하도록 해주기도 한다. 

- copy-on-write(COW)
    - 값의 변경(write)이 발생했을 때, 그 때 복제(copy) 하겠다는 것이다. 내용이 바뀔 때까지 부모의 내용을 공유하다가 바뀌게 되면(수정), 그 때 부모의 주소 공간을 카피하여 자식의 주소공간을 만든다. 

## 1. `fork()` 시스템 콜 

```c
int main()
{ int pid;
    pid = fork();
    if (pid == 0) // 자식
        printf("~~");
    else if (pid > 0) // 부모
        printf("~~");
}

```

`fork()`의 경우 자식 프로세스가 생길 때 부모 프로세스를 복제해준다. 정확하게는 복제하면서 PC(Program Counter)를 복제하기 때문에, 자식 프로세스는 `fork()` 호출 이후 코드부터 실행된다. 왜냐하면 부모가 `fork()`하면서 자식 프로세스가 복제되며 생성되는 것이기 때문에 PC는 자연스레 그 다음 줄의 코드를 가리키고 있을 것이다. 

복제 이후, 사실 자식/부모 프로세스는 동일하게 생겼기 때문에 구분이 어려워진다. 이 때문에 똑같은 흐름을 따라가야하는 문제점이 생기기도 한다.(구분이 어렵기 때문에 서로 다른 기능을 해주기 어렵다.) 그래서 자식/부모 구분을 해주기 위해 `fork()`의 결과값을 다르게 한다. 부모 프로세스의 결과값은 양수, 자식의 결과값은 0을 가지도록 한다. 이를 통해 부모/자식을 구분하고 서로 다른 기능을 하도록 해줄 수 있다. 

## 2. `exec()` 시스템 콜

`exec()` 코드를 만난 이후 부터 프로그램을 새로운 프로세스로 태어나게 해주는 역할을 한다. 

```c
int main()
{ int pid;
    pid = fork();
    if (pid == 0) // 자식
        printf("~~");
        execlp();
    else if (pid > 0) // 부모
        printf("~~");
}

```

`execlp()`를 만나게 되면 `execlp()` 내부의 프로그램으로 덮어씌워지게 된다. 

> 한 번 exec하면 다시 이전의 상태로 돌아갈 순 없다. 

자식 프로그램을 `fork()`한 이후 exec이 호출되기 때문에 다른 새로운 프로그램으로 덮어씌워지게 된다. 이 때문에 exec이후의 기존 코드는 영원히 실행이 되지 않게 된다. 

## 3. `wait()` 시스템 콜 

A가 `wait()` 시스템 콜을 호출하면 커널은 자식이 종료될 때까지 프로세스 A를 sleep 시킨다(block 상태) 

이후 자식 프로세스가 종료되면 커널은 프로세스 A를 깨운다(ready 상태)

## 4. `exit()` 시스템 콜 

프로세스를 종료시킬 때 사용한다.

- 자발적 종료 
    - 마지막 statement를 수행한 이후 `exit()` 시스템 콜을 통해 종료되는 경우
    - 프로그램에 명시적으로 명시적으로 적어주지 않아도 main 함수가 리턴되는 위치에 컴파일러가 넣어준다. 
- 비자발적 종료(외부에서 종료시킴)
    - 부모 프로세스가 자식 프로세스를 강제 종료시키는 경우 
        - 자식 프로세스의 한계치를 넘어서는 자원 요청
        - 자식에게 더 이상 할당된 작업이 없는 경우
    - 사용자가 kill/break를 직접 입력한 경우 
    - 부모가 종료되는 경우 
        - 부모 프로세스가 종료되기 전에 자식 프로세스가 먼저 종료된다. 

프로세스의 생성/실행/종료와 관련된 시스템 콜을 다시 한 번 정리해보자.

- `fork()` : 부모 프로세스를 복제 생성한다.
- `exec()` : 새로운 프로그램으로 덮어씌운다.
- `wait()`: 자식이 종료될 때 까지 sleep 상태로 기다린다.
- `exit()`: 프로세스를 종료시켜 자원을 반납하고 부모 프로세스에게 종료되었음을 알린다.


## 5. 프로세스 간 협력 

- 독립적 프로세스 
    - 프로세스는 각자의 주소 공간을 가지고 수행되므로 원칙적으로는 하나의 프로세스는 다른 프로세스의 수행에 영향을 미치지 못한다. 

- 협력 프로세스 
    - 프로세스 협력 메커니즘을 통해 하나의 프로세스가 다른 프로세스의 수행에 영향을 미칠 수 있다. 
    
### 프로세스 간 협력 메커니즘(IPC: Interprocess Communication)

> 1. 메세지를 전달하는 방법

- message passing: 커널을 통해 메시지 전달하는 방법이다.
    - 메시지를 전달하며 서로 실행되는 경우를 말한다 
    - 중간에 **커널**이 메신저 역할을 해준다.

#### 1-1. Direct Communication

통신하려는 프로세스의 이름을 명시적으로 표기하는 방법이다. 

![](https://i.imgur.com/p2L69VC.png)

#### 1-2. Indirect Communication

특정 프로세스를 표기하는 것이 아니라, mailbox 또는 port를 통해 메시지를 간접 전달하는 방법이다. 누가 이 메시지를 꺼내서 볼지는 보내는 프로세스에서는 모르게 된다.

![](https://i.imgur.com/nU6OkbZ.png)

어쨌거나 둘 다 모두 OS(커널)을 통해 통신한다는 것이 공통된 점이다. 

> 2. 주소 공간을 공유하는 방법

#### 2-1. shared memory

서로 다른 프로세스 간에도 일부 주소 공간을 공유할 수 있게 해주는 방법이다. 

![](https://i.imgur.com/ECWfw7Z.png)

프로세스끼리 직접 자발적으로 공유한다기 보다는 kernel에게 먼저 공유할 수 있도록 요청해서 초기 설정하게 된다. 초기 설정 그 이후부터는 사용자 프로세스 간에서 공유하며 작업하게 된다. 


## 6. CPU Scheduling 

- I/O bound job: CPU를 짧게 사용하고 중간에 I/O가 끼어드는 경우의 작업
    - 주로 사용자와 상호작용하는 작업
- CPU bound job: CPU만 오랜 시간 사용하는 프로그램의 작업
    - 계산과 같은 컴퓨터가 혼자 연산하는 작업

하나의 작업은 CPU busrt와 I/O burst가 번갈아가며 이루어지게 된다. (그렇지 않은 경우도 있다.)

이처럼 여러 종류의 job이 섞여있을 수 있기 때문에 CPU 스케줄링이 필요하다. 스케줄링을 통해 CPU와 I/O 장치 등 시스템 자원을 효율적으로 사용할 수 있게 된다. 

공평한 것 보다는 효율적인 것이 중요하고, 사용자 interactive한 작업에 대해서 적절하게 반응해주는 것이 중요하다. 

예를 들어 사용자가 스크린을 터치했을 때 처리해야하는 작업에 CPU가 너무 늦게 배정된다면 사용자에게 빠르게 응답을 줄 수 없을 것이다. 이러한 상황들을 고려하여 interactive한 job에 대해서는 오래 기다리지 않게 하고, 빠르게 대응해줄 필요가 있는 것이다. 이를 위해 CPU 스케줄링이 필요한 것이기도 하다. 

- CPU Scheduler
    - 누구한테 CPU를 줄지 결정하는 역할을 한다. 
    - 운영체제 내의 코드를 의미한다. 
    - 하드웨어가 아님!

- Dispatcher
    - CPU를 누구한테 줄 지 결정했으면 그 대상에게 CPU를 넘겨주는 역할을 한다. 
    - 이전 프로세스의 컨텍스트를 저장하고, CPU를 필요로 하는 대상 프로세스의 컨텍스트를 되돌려줘야 한다. (context switch)

- CPU Scheduling이 필요한 경우 
    - Running -> Blocked
        - I/O를 요청하는 시스템 콜 
    - Running -> Ready
        - 할당 시간 만료로 interrupt 받음
    - Blocked -> Ready
        - I/O 완료 후 interrupt 받음
        - CPU를 얻을 수 있는 권한을 준다
    - Terminate

위 경우의 스케줄링은 **nonpreemptive**(강제가 아니고 자진으로 반납)

거의 다른 스케줄링 기법은 **preemptive**(강제로 CPU를 빼앗는 방법)을 사용한다. 
