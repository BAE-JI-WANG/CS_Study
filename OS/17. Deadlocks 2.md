> 본 글은 이화여대 반효경 교수님의 [운영체제 강의(2014)](http://www.kocw.net/home/search/kemView.do?kemId=1046323) 내용에 대해 학습하고 정리한 내용입니다.


# 17. Deadlocks 2

## 0. Deadlock Detection and recovery

Deadlock을 방지하는 방법들의 오버헤드가 크고, 비용적으로 비효율적이기에 deadlock을 허용하자는 방법이다. 대신 deadlock을 탐지하는 루틴을 두고 발견시 recover하도록 하여 해결하는 방법이다. 

- 자원당 인스턴스가 하나 뿐인 경우
    - 자원할당 그래프에서의 cycle이 곧 deadlock을 의미한다. 
- 자원당 인스턴스가 여러 개인 경우 
    - Banker's algorithm과 유사한 방식 사용 

![](https://i.imgur.com/0BCTkkZ.png)


왼쪽 그래프는 프로세스와 자원 사이에서 요청/할당에 대한 정보를 그려준 것이다.

오른쪽 그래프의 경우 자원을 생략하고 프로세스만 나타내어 동일하게 표시한 것 이다. P4 -> P1의 의미는 P4가 P1이 가지고 있는 자원을 기다리고 있다는 의미이다. (위 경우는 100% deadlock이다.) 

프로세스가 n개일 때, 사이클을 탐지하는데에는 O(n^2)만큼 시간이 소요된다. 점이 n개일 때, 화살표는 n-1개 생길 수 있기 때문에 n * (n-1) 만큼의 시간이 걸리게 되는 것이다. 

하지만 그래프를 그리는 것 보다 테이블을 그려서 파악하는 것이 더 쉽다고 한다. 

![](https://i.imgur.com/zhsgrju.png)

- Request
    - 실제로 요청한 자원의 수 (추가 요청가능량이 아님!)

이 경우에는 조금 낙관적으로 생각한다고 한다. Request가 0인데 allocation에 값이 있는 경우 자원을 반납하게 될 것이라고 생각하는 것이다. 

즉 P0의 경우 B를 요청하고 있지 않기에 B를 1개 반환하여 availiable에 추가될 것이라는 것이다. P2도 동일한 맥락이다.

그렇게 되면 A:3, B:1, C:3으로 가용 가능해지며, P1의 request를 수용할 수 있는 것이다. 마찬가지로 요청 이후에 다시 반납할 것이라고 생각하기에 availiable의 값은 또 늘어나게 된다. 이러한 과정이 반복되면서 다른 프로세스에도 계속 자원을 할당해줄 수 있는 것이다. 

이제 모든 요청을 다 받아들이는 sequence가 존재한다는 것은 deadlock이 없다는 것이다.

![](https://i.imgur.com/kc4Mgan.png)

만약 위처럼 P2도 요청을 하게 된다면 이제는 P0만 반납을 하게 될 것이라고 생각하게 된다. 그러면 이제 B만 1개 가용 가능해지는 것이기에 다른 프로세스들이 요청하는 자원들은 할당해줄 수 없게 된다. 

왜냐하면 B를 요청안하고 A,C만 요청하고 있기 때문이다. 이에 요청 자체를 처리할 수 없는 상황이기에 deadlock이라고 볼 수 있는 것이다. 

그렇게 deadlock이 발견되면 Recovery를 해준다. 

두 가지 recovery 방법이 있다. 

- Process termination
    - deadlock이 발생한 프로세스를 죽여버리는 것이다. (연루된 모든 프로세스를 죽인다)
    - deadlock에 연루된 프로세스를 하나씩 죽여보고 deadlock인지 판단한다. 계속 deadlock이 발생하는지 확인하고, deadlock이 발생하지 않을 때 까지 하나씩 죽이면서 확인한다. 
- Resource Preemption
    - deadlock이 발생한 프로세스의 자원을 뺏는 방식이다.
    - 기본적으로 비용을 최소화할 프로세스 찾아서 해당 프로세스의 자원을 뺏는다(희생..)
    - 하지만 동일한 프로세스가 계속 희생양으로 지목이 되는 경우 Starvation이 발생하게 된다.(자원을 뺏는 패턴이 같다면 계속 같은 프로세스가 지목될 수 있다는 것) 
    - 그렇기에 비용을 최소화하는 것도 중요하지만, 프로세스가 몇 번 자원을 빼았겼는지도 고려해줘야 starvation을 극복할 수 있다. 

## 1. Deadlock Ignorance

Deadlock이 일어나지 않는다고 생각하고 아무 조치도 취하지 않는 방식이다. 

Deadlock 자체가 드물게 발생하므로, deadlock을 방지하는 비용이 오히려 많이 들어가고, 오버헤드가 높다는데 이유가 있다. 

만약 deadlock이 발생하게 되면 시스템은 아무 처리를 해주지 않고, 프로그래머가 직접 프로세스를 죽이는 등의 방법으로 해결해줘야 한다. 

이 방법의 경우 앞서 말한 것 처럼 대부분의 OS가 채택하고 있다!
