> 본 글은 이화여대 반효경 교수님의 [운영체제 강의(2014)](http://www.kocw.net/home/search/kemView.do?kemId=1046323) 내용에 대해 학습하고 정리한 내용입니다.


# 10. CPU Scheduling 1

작업 간에 효율적으로 CPU를 분배하기 위한 방법이라고 간단하게 이야기할 수 있다. 

CPU 스케줄링 알고리즘은 크게 2가지로 분류해 볼 수 있다. 

- nonpreemptive(비선점형: CPU를 강제로 빼앗지 않고 자진 반납하도록 한다)
- preemptive(선점형: 강제로 CPU 빼앗는다)

현대의 CPU스케줄링 기법은 preemptive의 성격을 갖는다고 한다. 이는 천천히 이유를 알아보자.

## 0. Scheduling Criteria (스케줄링 성능 척도)

우선 크게 2가지로 볼 수 있다. 

- 시스템 입장에서의 성능 척도 (= CPU 하나 가지고 일을 많이 시키면 좋은 것!)
    - CPU Utilization (이용률)
    - Thoroughput (처리량)
- 프로그램 입장에서의 성능 척도 (= 내가 CPU를 빨리 얻어서 빨리 끝내면 좋은 것)
    - Turnaround time (소요시간,반환시간)
    - Waiting time (대기 시간)
    - Response time (응답 시간)

이제 자세히 어떤 지표인지를 살펴보자

먼저 시스템 입장에서의 성능 척도를 봐보자. 

### 0-1. CPU Utilization

CPU가 놀지 않고 일한 시간의 비율을 나타낸다. 즉 CPU는 비싼 자원이기 때문에 놀게하지 말고 최대한 바쁘게 일을 많이 시키라는 의미로 볼 수 있다. 

### 0-2. Thoroughput

주어진 시간 동안에 몇 개의 작업을 완료했는지를 나타낸다. 위와 마찬가지로 CPU가 주어진 시간에 많은 일을 처리할 수 있다면 시스템 입장에서는 성능이 좋다라고 판단할 수 있을 것이다. 

이제 고객(프로그램/프로세스)입장에서의 성능 척도를 살펴보자. 

### 0-3. Turnaround time

CPU를 쓰러 들어와서 다 쓰고 나갈 때까지 걸리는 시간을 의미한다. (기다린 시간, CPU 쓴 시간 등을 다 더한 시간이다)

### 0-4. Waiting time

CPU를 ready queue에서 기다리는 시간을 의미한다. 줄을 서서 기다리는 순수한 시간만을 의미한다. (preemptive인 경우에는 계속 CPU를 얻었다가 뺐겼다가 반복되기에 기다리는 시간이 누적될 것이다. 이를 다 합치면 waiting time이 되는 것이다.)

### 0-5. Response time

ready queue에 CPU를 쓰겠다고 들어와서, CPU를 얻고 최초로 응답을 얻기까지 걸린 시간을 의미한다. 


그림으로 보면 아래와 같이 정리해볼 수 있다. 

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FruvCB%2Fbtrcb79EUPo%2FjE9Kl4jokNibMCZE8v3dYk%2Fimg.png)

이제 본격적으로 CPU 스케줄링 알고리즘들에 대해서 알아보자. 

## 1. FCFS (First-Come-First-Serve)

![](https://i.imgur.com/Hh6iSYM.png)


먼저 오면 먼저 처리해주는 `선착순`의 개념이다. 자료구조의 queue와 같은 원리로 처리된다. 

FCFS는 nonpreemptive 스케줄링이다. 먼저 도착해서 CPU를 점유하고 있다면 다른 프로세스에게 빼앗길 일이 없다는 것이다. 

하지만 이 방법의 경우 효율적이지는 않다. 만약 처리 시간이 많이 소요되는 프로세스가 먼저 도착해서 작업을 처리하고 있다고 하면, 뒤에 interactive한 프로세스가 도착하더라도 처리하지 못하고 계속 기다리고 있어야 할 것 이다. 

이에 간발의 차로 도착하더라도 처리 시간이 긴 프로세스가 먼저 CPU를 점유하게 된다면 다른 프로세스의 응답시간이 매우 커져서 비효율적이게 될 것이다. 

이와 반대로 처리 시간이 짧은 프로세스가 먼저 도착했다고 하면 평균 대기 시간이 매우 짧아질 수도 있다. 

즉, **처음 도착한 프로세스의 처리 시간에 영향을 매우 매우 많이 받게 되는 것**이다! 

이와 같이 처리 시간이 긴 프로세스로 인해 짧은 처리 시간을 가지는 프로세스들이 오래 기다려야 하는 상황을 **convoy Effect**라고 한다

## 2. SJF (Shoretest-Job-First)

이제는 처리 시간(CPU burst time)이 짧은 프로세스를 가장 먼저 스케줄링해준다는 것이다. 

앞의 FCFS에서의 단점을 봤듯이, 이제는 짧은 처리시간을 가지는 프로세스들을 먼저 처리해줌으로써 ready queue가 짧아지게 되고, 전체적인 평균 대기 시간(waiting time) 또한 짧아지게 될 것이다. 

SJF도 두 가지 경우가 있다. 

- nonpreemptive 방법
    - 중간에 더 짧은 프로세스가 도착하더라도 계속 기존의 프로세스를 처리한다.
- preemptive 방법
    - 중간에 더 짧은 프로세스가 도착하면 CPU를 뺏어서 전달해준다. 이를 SRTF(Shortest-Remaining-Time-First)라고도 부른다. 즉 남은 처리 시간이 짧은 프로세스에게 우선적으로 CPU를 주는 것이다. 

이 방법의 경우 두 가지 단점을 가지고 있다. 

- Starvation
    - 짧은 처리 시간을 가지는 프로세스를 우선적으로 처리해주기에, 처리 시간이 긴 프로세스는 계속 무한 대기하게 된다. 
    - 즉 처리 시간이 긴 프로세스는 영원히 처리되지 못할 수도 있다는 것이다... 
- 다음 CPU Burst Time의 예측이 어렵다
    - 프로세스가 어느 정도의 처리 시간을 가지게 되는지 파악하기가 어렵다. 
    - 그래서 추정을 통해 처리시간을 예측하게 되는데, 과거에 CPU를 얼마나 썼는지에 기반하여 계산하는데 정확하지는 않다고 한다.  
    
    
## 3. Priority Scheduling 

말 그대로 우선순위가 높은 프로세스에 CPU를 주겠다는 이야기이다. 

우선 순위의 기준은 여러 가지가 있겠지만 예를 들어서 보면 SJF도 Priority Scheduling의 종류 중 하나라고 볼 수 있다. 우선 순위가 `처리 시간`이 되는 것이다.

마찬가지로 Priority Scheduling에도 두 가지 버전이 있다. 

- nonpreemptive
    - 기존 프로세스 처리 중에 더 높은 우선 순위를 가지는 프로세스가 들어왔다고 해서 CPU를 빼앗기지 않고 계속 처리하는 방법이다.
- preemptive
    - 반대로 중간에 더 높은 우선 순위를 가지는 프로세스가 들어올 경우 CPU를 넘겨주게 되는 것이다. 

또한 단점으로 `Starvation`을 가지게 된다. 

마찬가지로 우선 순위가 낮은 프로세스는 평생 CPU를 받지 못할 수 있는 상황이 발생할 수 있기 때문이다. 

효율적인 처리도 중요하지만 조금의 공평성도 필요해지는 시점이 되는 것이다!

이에 `Starvation` 문제를 극복하기 위해 `Aging` 기법을 사용한다. 

아무리 우선 순위가 낮은 프로세스라도, 시간이 지날수록 우선 순위를 올려주어 끝내는 CPU를 받게 해주는 방식이다! (경로 사상 같은 거라고 한다..! )

### 4. RR (Round Robin)

![](https://i.imgur.com/4GsRrdu.png)

현대적인 컴퓨터 시스템에서 사용하는 스케줄링 기법은 이 RR에 기반하고 있다. 

각 프로세스는 동일한 크기의 할당 시간(time quantum)을 가지게 된다. 여기서 할당 시간이란 자원을 사용할 수 있는 제한 시간과 같은 것이다. 예를 들어 10초가 부여된다면, 어떠한 프로세스건 간에 10초만 작업을 처리하고 CPU를 다른 프로세스에게 념겨줘야하는 것이다. 이에 자연스레 **preemptive** 방식을 쓰고 있다는 것을 알 수 있다.

만약 10초간 작업을 했는데 아직 완료하지 못했다면은 다시 ready queue의 제일 뒤에가서 줄을 서게 된다. 즉, 일정 시간만 사용하며 프로세스들 간의 공평성을 조금 신경써준 방법이라고 볼 수도 있다. 

이에 모든 프로세스들은 조금만 기다려도 CPU를 점유할 수 있고, 작업을 일부 처리할 수 있게 되어, **응답 시간이 줄어들게 된다**. 이 덕분에 **Starvation** 또한 해결이 되는 것이다. 

그래서 n개의 프로세스들이 ready queue에 있고, q만큼의 시간을 준다고 하면 어떠한 프로세스도 `(n-1)q` 시간 이상으로 기다리지 않게 된다고 한다. 왜냐하면 한 바퀴, 한 바퀴 돌 때마다 q만큼은 확정적으로 처리할 수 있는 시간을 얻기 때문이다. 

> time quantum이 너무 크다면...?

만약 q를 너무 크게 잡으면 어떻게 될까? 앞에서 봤던 FCFS와 거의 같아지게 될 것이다. q가 엄청나게 크게 된다면 모든 프로세스는 q 이내에 작업을 완료할 수 있을 것이다. 이에 결국 먼저 들어온 것이 다 처리되고 다음 프로세스가 처리되는 FCFS의 작동 방식과 동일해지는 것이다. 

> time quantum이 너무 작다면...?

반대로 q를 작게 가지게 되면 너무 많은 context switch 오버헤드가 커지게 될 것이다. 프로세스들이 조금씩만 작업을 처리하고 CPU를 넘겨주고, 받게 되기 때문에 이 과정에서 오버헤드가 많이 발생하게 된다. 

이에 RR은 SJF보다는 평균 turnaround time은 길지만, response time은 더 짧게 가져갈 수 있다는 장점이 있다. 
