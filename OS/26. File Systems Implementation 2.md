> 본 글은 이화여대 반효경 교수님의 [운영체제 강의(2014)](http://www.kocw.net/home/search/kemView.do?kemId=1046323) 내용에 대해 학습하고 정리한 내용입니다.


# 26. File Systems Implementation 2

## 1. Page Cache and Buffer Cache

![](https://i.imgur.com/O70NKzY.png)

- read/write
    - 요청한 내용이 buffer cache에 있던 말던 우선 운영 체제에 요청해서 받아와야 한다
- Memory-mapped I/O
    - page cache에 올라온 내용에 한하여 운영체제 개입 없이 사용자 프로세스가 직접 메모리에 접근하듯이 사용할 수 있다.


양 쪽 모두 buffer cache에 있는 내용을 본인의 페이지에 복제해야하는 오버헤드는 존재한다.


Unified Buffer Cache의 경우를 보자.

read/write하는 경우는 무조건 시스템 콜이 발생한다. 운영체제는 메모리 내용을 사용자 영역에 카피해주기만 하면 된다. 만약 메모리에 내용이 없다면 디스크에서 읽어와서 사용자 프로세스에 카피해주면 된다.

memory-mapped I/O의 경우, 주소영역 일부를 파일에 매핑하는 단계가 필요하다. 페이지 캐시 자체가 사용자 프로세스 논리적인 영역에 매핑되기 때문에, 페이지 캐시에 읽고/쓰는게 가능하다.

code 영역은 읽기전용으로 파일 시스템에 파일로 존재하기 때문에 메모리에서 내려갈 때 swap area로 가지 않아도 된다고 한다. 필요한 경우 swap area에서 찾는게 아니라 다시 파일 시스템에서 찾아 사용해야한다. 

프로그램이 실행되다 보면, 특정 파일의 내용을 읽어오라는 시스템 콜을 할 수 있다. 혹은 데이터 파일 접근을 위해 memory-mapped I/O를 사용할 수도 있다. 

![](https://i.imgur.com/QHR0w5K.png)

프로그램이 실행이 되다가 데이터 파일을 사용하고 싶을 때, read/write 시스템 콜이 아니라 memory-mapped I/O 방식으로 쓰고 싶을 수 있다. 

그러면 우선 운영 체제에게 데이터 파일의 일부를 내 주소 공간에 매핑 해달라고 시스템 콜을 한다.

![](https://i.imgur.com/AOwDl6p.png)

매핑하면 이렇게 주소 공간 일부에 데이터 파일이 위치하게 된다.

프로그램이 실행되면서 해당 메모리 위치에 접근하게 되는데, 물리적인 메모리에 해당 내용이 존재한다면 그대로 접근하면 된다. 하지만 그 내용이 메모리에 올라와있지 않은 경우 page fault가 발생한다.

그러면 CPU가 OS에게 넘어가게 되고, OS는 파일 시스템에서 해당 내용을 다시 읽어와서, 물리적인 메모리에 page fault가 발생한 page를 올려주게 된다.

그 이후부터는 가상 메모리의 페이지가 물리적인 메모리의 페이지와 매핑되는 것이다. 그래서 프로세스가 데이터 파일에 접근할 때는 본인의 주소공간에 접근하는 것과 같기 때문에, 읽고 쓰고 할 수 있다. 나중에 물리적인 메모리에서 쫓겨나게 될 때는 swap area에 수정된 내용을 쓰는 것이 아니라, memory-mapped 파일이기 때문에 파일에다가 수정된 내용을 작성하고 쫓아내야 한다. 

다른 프로세스도 접근하고자 하면, 해당 물리적인 메모리 내용을 공유해서 사용하게 된다. (이 때 일관성 문제가 발생할 수 있다.)

read 시스템 콜을 하는 경우, 기존 캐쉬(물리적인 메모리)에 있던 내용을 프로세스 본인에게 카피해온다.

정리해보자.

- Memory-mapped
    - 내용을 카피가 아니라 매핑하여 쓰는 것
    - 메모리에 올라온 파일의 내용은 시스템 콜 하지 않고, 프로세스가 CPU를 가지고 있으면서 직접 접근할 수 있다. (=운영체제의 도움이 없어도 된다.)
    - 그래서 더 빠르다!
    - 캐쉬에 올라온 내용을 본인의 메모리에 카피하는 과정이 없다.
    - 주의할 점
        - 매핑이기에 일관성 문제가 발생할 수 있다. 
        - 여러 프로세스가 접근하는 경우 데이터가 원치 않게 달라질 수 있다는 것이다. 
- read/write
    - 카피해서 전달
    - 카피이기에 일관성에 대한 문제가 없다.
    - 운영체제가 중간에서 제재한다. 
